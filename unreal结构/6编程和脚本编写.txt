用C++编程
	1、虚幻引擎反射系统
	2、虚幻引擎中的容器：虚幻中各种类和数据结构的信息
		1、TArray：虚幻中的数组：速度快、内存消耗小、安全性高；两大属性-元素类型和可选分配器；存储在数据中的对象类型，同质容器：
			Add/Push;Emplace{优于Add}; 迭代、排序、查询、移除、运算符、堆、Stack、原始内存、其他{BulkSerialize是序列化函数，替代运算符<<}、{CountBytes、GetAllocatedSize}、{Swap、SwapMemory}
		2、TMap：常用容器-TMap/TSet，键值对(TPair<KeyType,ValueType>,只将键用于存储和获取)----稀疏数组、
			{创建和填充映射、迭代、查询、移除、排序、运算符、Slack[不包含元素的已分配内存]、KeyFuncs[具有运算符==和非成员GetTypeHash重载，作为TMap的键类型，不需任何更改]、其他}
			支持复制、赋值和析构函数运算，以及元素的强所有权；在映射时被销毁时，它的元素都会被销毁，键和值也必须为值类型；
			散列容器，支持GetTypeHash,提供运算符==，比较各个键是否等值
		3、TSet：使用数据本身作为键，而不是将数据值与独立的键相关联；
			{创建和填充集合，迭代，查询，移除，排序，运算符，Slack，DefaultKeyFuncs，其他}
	3、游戏性架构{https://docs.unrealengine.com/5.3/zh-CN/programming-with-cpp-in-unreal-engine/}
		断言：assert等同项的三个不同族系：check、verify、ensure
		游戏性类：添加类、类头{类生命-类说明符}、类实现{类构造函数-[构造函数格式、构建函数静态属性和助手-[资源引用、类引用、组件和子对象]}
		游戏模块：编译成DLL的游戏项目的游戏性相关类的集合
			模块创建-INI文件设置
			多个游戏性模块
			限制-保证dll模块的独立性
		Gameplay标签：用户定义的字符串，充当概念性的分层标签
			定义Gameplay标签、在项目设置中添加标签、数据表资产导入标签、使用C++定义标签、将标签应用于对象、使用条件函数对标签求值、
			高级主题：设置标签编辑限制、简化C++中的标签访问
		虚幻中的日志记录：
			虚幻中的日志功能提供了多种方法：有序记录运行时特定时刻的事件、函数调用和变量值
			UE_LOG、日志详细级别、控制台命令、日志记录基础数据类型、定义你自己的日志类型、UE_LOGFMT、屏幕调试信息
		C++编程教程{https://docs.unrealengine.com/5.3/zh-CN/unreal-engine-cpp-programming-tutorials/}
			游戏摄像机：场景中放置摄像机、C++中控制摄像机视图、完成的代码、放置Camera Director、自主操作
			组件和碰撞：半成品代码、配置输入和创建Pawn移动组件、为Pawn移动组件的行为编写代码、
			编程快速入门：必要设置、创建新C++类、编辑C++类、编译和测试C++代码、最终结果->自己动手操作
			第一人称设计游戏教程：建立项目、实现角色、实现发射物、增加角色动画
			玩家控制的摄像机：将相机连接到pawn、配置输入以控制摄像机、编写C++代码以便响应输入操作
			玩家输入和Pawn：对Pawn类进行扩展。以便响应玩家的输入操作；配置游戏输入、编写和绑定游戏操作
			变量、定时器和事件：公开变量和函数的方法--使用定时器延迟或重复代码执行的方法，以及使用事件再Actors间通信的方法；
				{https://docs.unrealengine.com/5.3/zh-CN/quick-start-guide-to-variables-timers-and-events-in-unreal-engine-cpp/}
	4、委托
		泛型但类型安全的方式，可在C++对象上调用成员函数，可使用委托动态绑定到任意对象的成员函数；在该对象上调用函数，即使调用程序不知对象类型也可进行操作；
		声明委托、绑定委托、载荷数据、执行委托
			动态委托：可序列化，其函数可按命名查找，但是执行速度比常规委托慢{声明动态委托、动态委托绑定、执行动态委托}
			多播委托：声明多播委托、绑定多播委托、多播执行
	5、代码规范{https://docs.unrealengine.com/5.3/zh-CN/epic-cplusplus-coding-standard-for-unreal-engine/}
		最重要的是保持一致性和可读性
			规范原因{软件生命周期中80%的时间需要维护、原开发者几乎不会对软件进行终身维护、软件可读性、源代码需要易于理解、交叉编译器兼容性需要此类规则}
			类组织
			版权声明：严格的版权声明
			命名规范：{
				所有的代码和注释都应采用美式标准英语的拼写和语法
				命名[类型或变量]中的每个单词需大写首字母，单词间通常无下划线----
				类型名前缀需要使用额外的大写字母，用于区分其与变量命名，如FSkin为类型名，而Skin则是FSkin的实例
					模板类的前缀是T、继承子UObject的类前缀U、继承自AAActor的类前缀A、继承自SWidget的类前缀为S
					抽象界面类的前缀为I
					Epic提供的概念类型的类(用作TModels的第一个参数或bHasFadedIn)
					其他多数类均以F为前缀，而部分子系统则以其他字母为前缀
					Typedefs应以任何与其类型相符的字母为前缀：若以结构体的Typedefs，则使用F；若为UObject的Typedefs，则使用U，以此类推
						特别模板化的实例化的Typedef不再是模板，应加上响应前缀；
						枚举的前缀为E；
						布尔变量必须以b为前缀(bPendingDestruction或bHasFadedIn)
						C#中省略前缀；
						UnrealHeaderTool需要正确的前缀，因此添加前缀至关重要；
				类型模板参数和基于这些模板参数的嵌套类型别名不受上述前缀规则的约束，因为类型的类别是未知的
					{一般在描述性术语后添加一个Type后缀；通过In前缀，将模板和别名区分开}
				类型和变量的命名为名词
				方法名是动词，以描述方法的效果或未被方法影响的返回值
				宏应该全部大写，用下划线隔开，并以UE_作为前缀
			}
		变量、方法和类的命名应清楚、明了且进行描述，命名的范围越大，一个良好的描述性命名就越重要，避免过度缩写；
		所有的变量应逐个声明，以便对变量的含义提供注释，变量前可使用多行或单行注释，空白行为为分组变量可选使用；
			所有返回布尔的函数应发起true/false的询问，如"IsVisible"或"ShouldClearBuffer"; 
			程序应在Object后使用强变化动词，需以上下文来理解Object，避免以"Handle"和"Process"为开头；此类动词会引起歧义
			若函数参数通过引用换地，同时该值会写入函数，建议以"Out"作为函数参数命名的前缀，此操作将明确表明传入该参数将被函数替换
			若In或Out参数同样为布尔，以b作为In/Out的前缀，如bOutResult；
			返回的函数应描述返回的值，命名应说明函数将返回的值；
		包容性选词：避免歧视用语
		可移植C++代码：
		应该避免在同一API中混合使用UE规范和标准库规范：
			<atomic>/<type_traits>/<initializer_list>/<regex>/<limits>/<cmath>/<cstring>
		注释：指南{编写含义清晰的代码、编写有用的注释、不要对低质量代码进行注释----重新编写这些代码、不要让代码与注释自相矛盾、常量正确性[常量即是文档也是编译器指令]}
			常量正确性：
				若函数不修改参数，常量指针或引用将传递函数参数；
				若方法不修改对象，将方法标记为常量；
				若循环不修改容器，则在容器上使用常量迭代；
			基于值的函数参数和本地值通用倾向常量，读取者可了解函数主题不会修改变量，使之易懂；
				操作影响javaDoc进程，因此此操作时须确保声明与定义相匹配；
			按值传递参数，这种参数最终会被移动到容器中，不过这种参数应该很少见；
			创建指针的常量时，将常量关键字放在末尾(而非指针所指之处)，无法“重新指定”引用，无法以相同方式创建常量；
			绝不要在返回类型上使用常量，此操作将会禁止复杂类型的移动语义，并会对内置类型发出编译警告；此规则仅适用于返回类型自身，而非指针目标类型或返回的引用；
		范例格式：
			基于JavaDoc的系统从代码和版本文档中自动提取注释：类、方法和变量注释的格式，代码说明实现，而注释说明意图；代码记载实现，而注释记载目的，修改代码的部分目的应及时更新注释；
			以下例子时类、方法和变量注释的格式：{注释应扩大代码，代码说明实现：注释说明意图--代码记载实现，注释记载目的，修改代码的部分目的后应及时更新注释；}
			类注释：此类解决的问题的描述、创建此类的原因；
			多行法注释的所有部分的意义：函数目的{该函数解决的问题}、参数注释{左右参数注释：计量单位、预期值范围、"无可能"值、状态/错误代码的含义}、返回注释{预期返回值的方式与记载输出变量相同，为避免冗余：}、其他信息{@warning,@note,@see,@deprecated}
			现代C++语言语法{静态_断言、覆盖与完成、nullptr、"auto"关键字、基于范围{TMap(),Key(),Value(),TPair()}}--部分独立迭代器类型拥有替代范围
			匿名函数：
				可自由使用匿名函数，在家的匿名函数长度不应超过两条语句，常用的状态行匿名函数无法指定至函数指针；<---> 匿名函数运行时，新创建一个对象
			强类型化枚举
			移动语意：Move Semantics
			默认成员初始器
			第三方代码
				注释编程原因：   例如：注释方式 @third party code
			代码格式：
				大括号：
				if-Else：
				制表符和缩进：
				切换语句：
				命名空间：
				物理依赖性：
				封装：
				一般格式问题：
				API设计指导方针：避免使用bool函数参数，优先使用枚举类型：放置意外置换标签，避免指针和整数参数中转换；无需多余默认值，从而变得更加高效；、、、；避免过长的函数参数列表，函数使用多个参数，选择传递专属结构体；避免使用布尔和"FString"重载函数；接口类(固定为抽象，切不可拥有成员变量)；声明覆盖方法时应使用虚拟和覆盖关键字；若派生类中声明虚幻函数，必须同时使用虚拟和覆盖关键字；
			平台特定代码：固定抽取平台特定代码，并正确命名的子目录中平台特定源文件内实现；
蓝图可视化脚本：策划与程序之间的交互
	1、蓝图最佳实践
		蓝图可执行许多操作：非每帧调用的操作: 每个tick都执行大量操作和复杂的数学计算；
		类变量vs.本地变量：：：：
		函数vs.宏：：：：发送输入到节点，事件发生，然后进行输出；存在共性{用于编辑节点功能的中心区域[宏拥有宏图表，函数拥有函数图表]}，中央区域变化后，调用函数或宏的每个节点均会更新；
		两者均可重复使用；两者均使用本地变量，宏使用没有特定的命名，只保存数值的"匿名"本地变量
		两者均适用于封装重复使用和清晰性功能
		高级使用：：放置节点调用函数时，函数将被实际调用，意味着可以函数为目标，而函数则形成蓝图之间的通信；
			宏接受来自宏图表的节点，并用所有这些节点的副本实际替换宏节点，根本而言，蓝图编译时，宏将复制所有图表的节点，将它们粘贴到宏节点所在之处；
		蓝图通信类型：事件分配器或蓝图
			设置蓝图：每个人的图表设置偏好不同，以下提示可助你对内容进行组织，易于使用；
			如一个图表中使用相同节点集超过两次，可考虑将其设为函数或宏以便重复使用；
			通过节点上下文进行堆栈可使用内容在空间上更加紧凑；
		蓝图命名空间可以防止加载不必要的资产，从而加快蓝图资产的打开时间：引擎通常会在初始化时加载所有的蓝图函数库和宏库资产；
			通过将资产分组成为蓝图命名空间，你可以推迟资产的加载时间，让它们在需要的时候加载；
			filtered function：过滤函数
	2、蓝图命名空间
	3、蓝图编辑器参考
	4、蓝图技术指南
	5、蓝图简介
	6、蓝图指南
	7、蓝图剖析
	8、专用蓝图节点组
	9、蓝图调试器
类创建基础知识
	1、Blueprints Only
	2、C++和蓝图
	3、仅使用C++的示例
在线子系统和服务
	1、在线服务
	2、在线子系统
	3、Epic Online Services in UE
	4、语音聊天接口
虚幻架构
	1、资产异步加载{异步代码，可改善游戏卡顿和降低内存占用}
		FSoftObjectPaths/TSoftObjectPtr: 创建硬指针
		资源注册表和对象库
		StreamableManager和异步加载：
	2、C++中的控制台变量
		创建/注册控制台变量
		获取控制台变量的状态
		追踪控制台变量修改
		控制台变量预期行为和风格
		加载控制台变量
		命令行
		优先级
		取消注册控制台变量
	3、Core Redirecte
		使在加载时重新映射类、列举、函数、包、属性和结构体成为可能
		名称灵活性和独特性
		子字符串匹配
		调试核心重定向
	4、Data Assets
		创建一个data Asset：
	5、数据验证
	6、虚幻引擎模块
		使用Modules的优势：
			好的代码隔离，提供概括并隐藏代码内部实现
			模块是编译成独立的编码单元，意味着只有模块需要编译，且针对大型项目来说更加快
			模块通过依赖图建立连接，限制header引用；
			可在运行时控制模块的加载与卸载
			模块在某些条件下，可进行处理
		建立一个module：// 理解Module的结构体//在Build.cs文件中构建依赖
			private和public依赖；使用private和public文件夹
		在你的项目中使用模块，控制模块如何加载
			创建GamePlay模块：UE模块是一个有用的方式组织代码，增加code到你的module中；Extend Code From your module
	7、引用资产
		Referencing Assets： 
				Direct Property Reference/Construction Time Reference/Indirect Property Reference/ Find(Load) Object
	8、资产注册表
		Asset Registry:
				Obtaining a List of Assets: 获取一系列的Assets
				转换FAssetData到UObject:；Creating a Filter： 
					PackageName,PackagePath,Collection,Class,Tags/Value pairs
					Tags&Values
					Asynchronous Data Gathering: 异步数据收集
	9、字符串处理
		String Handle: FName,FText,FString
				Character Encoding: TextFormats，The Case for Binary/Text/UTF-8/UTF-16/UE Internal String Representation/Text Files Loaded by UE
				Storing UTF-16, Conversion Routines,ToUpper() and ToLower() Non-Trivial in Unicode;
			Searching the Name Table: FName{创建、转换和对比FNames的引用}
	10、编程子系统
		UE的子系统是生命周期受控的自动实例化类，
			引擎： UEngineSubsystem
			编辑器： UEditorSubsystem
			游戏实例： UGameInstanceSubsystem
			本地玩家： ULocalPlayerSubsystem
		使用子系统的原因：
			节约时间、无需覆盖引擎类、无需添加更多的API、通过类型化节点访问蓝图、允许python编写脚本或者测试代码、在代码库中提供模块化和一致性
		使用蓝图访问子系统
		子系统生命周期细节
			引擎子系统
			编辑器子系统
			GameInstance子系统
			LocalPlayer子系统
			子系统范例： 希望为游戏添加一个统计数据系统，以跟踪收集资源的数量；
	11、任务系统
		任务系统是一种作业管理器，提供了异步执行Gameplay代码的能力，支持构建和运行依赖人物的定向无环图，对UE中使用的作业管理器TaskGraph的改进，任务系统
		和TaskGraph使用相同的后端(调度程序和工作线程)；
		主要功能：
			启动任务：方法是提供需要异步执行的可调用对象
			等待任务完成和/或检索任务执行结束
			指定任务先决条件，即开始执行该任务之前必须完成的其他任务
			从任务内部启动嵌套任务，父任务只有其所嵌套任务都完成后才算完成；
			构建任务链，也成为管线
			使用任务事件执行任务之间的同步和信令
		启动：
			启动任务，需要提供任务的调试名称和可调用的对象"任务主体"
			技术细节： FTask，实际任务的句柄，类似于智能指针，使用引用计数管理生命周期，启动任务即开始其生命周期，分配所需的资源，释放持有的引用；
			等待任务完成、忙等待、先决条件{人物之间可以产生依赖性，构建任务的定向无环图}、嵌套任务{先决条件是执行依赖性、嵌套任务是完成依赖性}、
			管线：一个接一个(非并发)执行的任务链，通过锁互斥锁"锁定"资源，常常因为线程被组织而带来重大的性能损失{uniTask}，尤其是在争用资源的情况下
			Pipe API是线程安全的；Pipe对象不可复制，且不可移动；一个任务无法在多个管线中启动；
			任务事件：任务时间是一种特殊的任务类型，没有任务主题，不能执行工作；重大区别：任务事件最初不会启动(发信令)，需要显示触发；
			调试与分析：
				每个任务、任务事件或管线都有用户提供的调试名称，这样就可以在调试器中运行时期识别他们，VS原生查看器可用于检查其内部状态；
				UE提供了任务追踪通道，支持可视化任务及其生命周期事件，如在任务启动、调度、执行和完成时；
			TTask<ResultType>: 实际任务的句柄，它使用引用计数器来管理任务的生命周期；
			TTask<ResultType>::IsValid(): 函数，在任务句柄引用一个任务返回true，默认构造的任务句柄为”空“，因此无效，任务在启动时构造；
			Task<ResultType>::Launch： 启动任务进行异步执行，在下面的代码示例中，Launch用于一个任务，并返回句柄
			先完成其他依赖的任务，然后执行该任务，所有先决条件都完成后，该任务会自动安排执行；
			TTask<ResultType>::IsCompleted: 如果已完成或者无效
			TTask<ResultType>::Wait:阻塞当前线程，直至任务完成或等待发生超时，超时后返回false
			TTask<ResultType>::BusyWait:忙等待是指在等待该任务完成的同时执行其他无关任务，了提高任务吞吐量，应谨慎使用
			TTask<ResultType>::GetResult 范围该任务因其执行所返回的对象的引用(任务主题执行返回的值)
			AddNested():: 将给定任务注册为”当前“任务，的嵌套任务，当前任务是当前线程所执行的任务；
			FTaskEvent: 将API的一部分与TTask<ResultType>共享，IsValid(),IsComplete()等待和忙等待API是相同的；
				FTaskEvent构造函数
				FTaskEvent::AddPrerequisites 将其他任务添加为先决条件
				FTaskEvent::Trigger
			FPipe： 管道是不可复制、不可移动的轻量级对象，管道的构造不会分配动态内存，并且不会执行昂贵的处理
				构造函数{使用给定调试名称创建任务事件对象}}、析构函数{检查管道是否有未完成的任务，销毁时不能存在没有完成的任务}、
				HasWork(): 检查管道是否有未完成的任务
				WaitUtilEmpty():调用将阻塞，直至管道的所有任务都完成
				Launch()：在管道中启动一个任务，相同管道中启动的任务不会并发执行(一个接一个)，但可以由不同的工作线程执行；
				IsInContext():如果从属于该管道的任务内部调用，则返回true，可以用于检查访问受管道保护的共享资源是否安全，
	12、配置文件
		语法：分段名称{模块、插件、蓝图、自定义分段名称}
		注释：
		键/值对：数组、结构体、字符串
		项目中的配置文件：
			配置文件类目{通用、Editor、桌面}
			配置文件层级{层级示例}
		在代码中使用配置变量
			将配置设置应用于变量{自动：分段格式、自动加载配置变量的步骤；手动：手动读取选项[函数、配置类目]}
		编辑配置设置：代码中保存配置设置
	13、命令行参数
		通道命令函参数
			相关控制台命令
		使用命令行覆盖配置
			特定配置文件属性{命令、描述、示例} 、 类目中的默认文件、类目中的所有文件、具有匹配后缀的配置文件、所有配置文件、
			在配置文件中设置控制台变量、可提供更多信息的有用源文件
			标记和键值对
			渲染和GPU
			CPU和内存
			调试
	14、资产和包的版本控制
		自定义序列化代码和版本控制以控制如何从资产和包加载Object
开发设置
	1、Xcode
		https://dev.epicgames.com/documentation/zh-cn/unreal-engine/using-modern-xcode-in-unreal-engine-5.3-and-newer
	2、设置Visual Studio
		https://dev.epicgames.com/documentation/zh-cn/unreal-engine/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engine
	3、为虚幻引擎设置VS Code
		
	4、下载虚幻引擎源代码
	5、从源代码构建虚幻引擎
	6、编译配置参考
	7、管理游戏代码
	8、编译游戏项目
	9、Live Coding
	10、编程工具
		低级内存跟踪器
		Sparse Class Data